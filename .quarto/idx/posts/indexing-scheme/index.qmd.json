{"title":"Linearly indexing a 2D grid","markdown":{"yaml":{"title":"Linearly indexing a 2D grid","author":"Akshay Shankar","date":"2025-05-01","categories":["tidbit","number theory"]},"headingText":"Constructing the indexing scheme","containsRefs":false,"markdown":"\n\nRecently, I had to write an exact diagonalization routine to solve for the ground state of a system of interacting bosons in the continuum. Generally this simply involves choosing a single-particle basis set, $\\{\\phi_i(\\vec{r})\\}|_{i=1}^N$ such that a many-particle basis set may be constructed by enumerating the Fock states, $\\{\\ket{n_1, n_2, \\dots, n_N}\\}$ respecting the bosonic/fermionic symmetry. These states can then be utilized to explicitly construct the Hamiltonian by computing its matrix elements. \n\nWe see then that the core subroutine is agnostic to the physical dimensionality of the problem as this information is already abstracted out at the level of the Fock states. In such a case, extending a code developed with 1D systems in mind to higher dimensions is as simple as finding a consistent linear indexing scheme for the single-particle basis set in order to construct the basis of Fock states.\n\nIn my particular case, I was working with a 1D system under the influence of a harmonic potential, so the Hermite modes, $\\{h_n(x)\\}$ where $n \\in \\mathbb{N}$ with single-particle energies $\\epsilon(n) = \\hbar \\omega (n + 1/2)$, served as a natural single-particle basis. Upon requiring an extension to 2D, a natural choice for the basis can be constructed as a product of the 1D modes, $\\{h_{n_x}(x)h_{n_y}(y)\\}$ where $n_x, n_y \\in \\mathbb{N}$ with single-particle energies $\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)$. We thus require a mapping scheme $\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$ in order to linearly index this basis set.\n\n\nThe modes are labelled by two numbers $(n_x, n_y)$, both of which are non-negative integers. A natural ordering scheme presents itself in the form of increasing energy eigenvalues, however the spectrum is fairly degenerate since $\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)$. This degeneracy actually lets us come up with a scheme quite easily.\n\n![](mapping.png){width=500px fig-align=\"center\"}\n\nWe can break down the scheme into two pieces; (1) identify the degeneracy level, (2) identify the location within the level. We know that a mode $(n_x, n_y)$ must belong to a level with degeneracy $n_x + n_y + 1$. This means that the number of elements in the lower energy levels is given by:\n\n\\begin{equation} \\sum_{n = 1}^{n_x + n_y} n  = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2} \\end{equation}\n\nWithin the level, $n_y$ itself provides a natural way of ordering the modes. We can thus write a linear indexing scheme like so:\n\n\\begin{equation} n = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2}  + n_y \\end{equation}\n\nOf course, we could equivalently use $n_x$ instead. \n\nAlthough it is not readily apparent due to the quadratic nature of this mapping, we expect that it is invertible by construction. In such a case, we have effectively constructed a bijection from the natural numbers to a pair of natural numbers. In fact, what we have here is [Cantor's pairing function](https://en.wikipedia.org/wiki/Pairing_function#Inverting_the_Cantor_pairing_function), which is the _only_ bijective quadratic function on $\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$. The existence of this function shows that 2-tuples of natural numbers are countable! By extension, we can easily show that the set of rational numbers are countable as well.\n\nWhile its not too surprising that this result is well-known and has ties to number theory, I found it really nice that it naturally popped up as a practical solution to a seemingly unrelated logistical problem involving the numerical implementation of exact diagonalization.\n","srcMarkdownNoYaml":"\n\nRecently, I had to write an exact diagonalization routine to solve for the ground state of a system of interacting bosons in the continuum. Generally this simply involves choosing a single-particle basis set, $\\{\\phi_i(\\vec{r})\\}|_{i=1}^N$ such that a many-particle basis set may be constructed by enumerating the Fock states, $\\{\\ket{n_1, n_2, \\dots, n_N}\\}$ respecting the bosonic/fermionic symmetry. These states can then be utilized to explicitly construct the Hamiltonian by computing its matrix elements. \n\nWe see then that the core subroutine is agnostic to the physical dimensionality of the problem as this information is already abstracted out at the level of the Fock states. In such a case, extending a code developed with 1D systems in mind to higher dimensions is as simple as finding a consistent linear indexing scheme for the single-particle basis set in order to construct the basis of Fock states.\n\nIn my particular case, I was working with a 1D system under the influence of a harmonic potential, so the Hermite modes, $\\{h_n(x)\\}$ where $n \\in \\mathbb{N}$ with single-particle energies $\\epsilon(n) = \\hbar \\omega (n + 1/2)$, served as a natural single-particle basis. Upon requiring an extension to 2D, a natural choice for the basis can be constructed as a product of the 1D modes, $\\{h_{n_x}(x)h_{n_y}(y)\\}$ where $n_x, n_y \\in \\mathbb{N}$ with single-particle energies $\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)$. We thus require a mapping scheme $\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$ in order to linearly index this basis set.\n\n## Constructing the indexing scheme\n\nThe modes are labelled by two numbers $(n_x, n_y)$, both of which are non-negative integers. A natural ordering scheme presents itself in the form of increasing energy eigenvalues, however the spectrum is fairly degenerate since $\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)$. This degeneracy actually lets us come up with a scheme quite easily.\n\n![](mapping.png){width=500px fig-align=\"center\"}\n\nWe can break down the scheme into two pieces; (1) identify the degeneracy level, (2) identify the location within the level. We know that a mode $(n_x, n_y)$ must belong to a level with degeneracy $n_x + n_y + 1$. This means that the number of elements in the lower energy levels is given by:\n\n\\begin{equation} \\sum_{n = 1}^{n_x + n_y} n  = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2} \\end{equation}\n\nWithin the level, $n_y$ itself provides a natural way of ordering the modes. We can thus write a linear indexing scheme like so:\n\n\\begin{equation} n = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2}  + n_y \\end{equation}\n\nOf course, we could equivalently use $n_x$ instead. \n\nAlthough it is not readily apparent due to the quadratic nature of this mapping, we expect that it is invertible by construction. In such a case, we have effectively constructed a bijection from the natural numbers to a pair of natural numbers. In fact, what we have here is [Cantor's pairing function](https://en.wikipedia.org/wiki/Pairing_function#Inverting_the_Cantor_pairing_function), which is the _only_ bijective quadratic function on $\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$. The existence of this function shows that 2-tuples of natural numbers are countable! By extension, we can easily show that the set of rational numbers are countable as well.\n\nWhile its not too surprising that this result is well-known and has ties to number theory, I found it really nice that it naturally popped up as a practical solution to a seemingly unrelated logistical problem involving the numerical implementation of exact diagonalization.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.29","theme":["cosmo","brand","cerulean"],"title-block-banner":true,"title":"Linearly indexing a 2D grid","author":"Akshay Shankar","date":"2025-05-01","categories":["tidbit","number theory"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}