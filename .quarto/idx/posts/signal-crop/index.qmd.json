{"title":"Automating image cropping","markdown":{"yaml":{"title":"Automating image cropping","author":"Akshay Shankar, Dhruva Sambrani","date":"2025-05-04","categories":["tidbit","code","bec"],"image":"image.jpg"},"headingText":"Automating the cropping","containsRefs":false,"markdown":"\n\nSometimes being a (numerical) theorist gets a bit tiring. In those moments, I occasionally peak into what my colleagues are working on with the [BEC experiment](https://quantumghent.github.io/bec/) downstairs. If they happen to be facing an interesting logistical problem, its quite fun to see if it can be automated with code. One such problem popped up early on in the calibration phase of the experiment; namely, we had to profile a certain gaussian laser beam belonging to the [AOD system](https://en.wikipedia.org/wiki/Acousto-optic_deflector) to see if it was tuned correctly. Typically, this involved capturing 2D images of the intensity profile like so: \n\n```{julia}\n#| echo: false\nbegin\n    using Pkg\n    Pkg.activate(\"../../\")\n    Pkg.instantiate()\n    using JLD2, Plots, StatsBase\nend\n```\n\n```{julia}\nbegin\n    data = load(\"signal.jld2\")[\"images\"]\n    plot(heatmap(data[1], title=\"Image #1\"), heatmap(data[2], title=\"Image #2\"), size=(1000, 300))\nend\n```\n\nThese images have quite a high resolution but the actual signal is tiny and most of the space is just empty. So, before running any analysis routines on this data, it must be cropped to put the actual beam in focus. Nowadays this can be easily achieved with the host of computer vision algorithms that can be found in mature ecosystems such as OpenCV. However, I wanted to see if a simpler approach was possible here since the signal is not particularly complex in its structure. In the ideal case, it is supposed to be an exact gaussian beam, although in this particular instance, there was some odd modulation of interference fringes within the spot which is what we wanted to investigate.\n\nI have not spent too much time to figure out exactly why the solution works, so I simply outline the procedure here and discuss how we stumbled upon it. I should note here that what follows was largely borne out of discussions with [Dhruva Sambrani](https://dhruvasambrani.github.io/).\n\nBefore proceeding, we assume that there is only a single point of interest and it is roughly a single-peaked intensity distribution. Finding the point of interest (i.e., the signal peak) is usually not too hard since one may use boxed-averages or some other sophisticated algorithm (there is an _excellent_ [stack exchange thread](https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data) on this) to locate regions of interest where the intensity peaks. Obtaining a measure of the spread of the spot is a bit harder though. Ideally the signal is equipped with a standard deviation as it is a gaussian beam, but we cannot perform a linear regression to fit it to this model and extract the parameter as such (the whole point is to reduce the size of the image before doing these things). One may also just compute $\\sigma = \\sqrt{\\int x^2 \\cdot I(x) dx - (\\int x \\cdot I(x) dx)^2}$ using the discrete data with $x$ being the pixel co-ordinates. But this would require performing independant calculations across multiple cross-sections (either horizontal/vertical or radially outwards) and averaging those out, but we are lazy programmers trying to find the path of least action. So we instead look for some simpler qualitative measure that approximately gives us the spread.\n\nThe rough idea is as follows; we expect that the standard deviation of the intensity values around the peak of the beam should hold the information of the signal spread (there is likely a direct relation here). This is simple to compute; $stddev(I) = \\frac{1}{N} \\sum_{i} (I_i - \\bar{I})^2$ where $\\bar{I}$ is the mean intensity within the area. However, we do not know how large an area around the peak must be considered to compute this deviation. \n\nIn order to facilitate the exploration of this concept, we first write a small function to extract the indices corresponding to a (hyper-cube) of length `2 * window` centered around the point `anchor`. All the code in this post is written to be applicable regardless of the dimensionality of the data.\n```{julia}\nfunction cube(anchor, window)\n    return [\n        rmin:rmax for (rmin, rmax) in\n        zip(anchor .- window, anchor .+ window)\n    ]\nend\n```\n\nWe then define the measure of the extent of the signal as the standard deviation of the intensity values in a cube of pixels centered around the signal peak.\n```{julia}\nmeasure_extent(data, anchor, window) = std(data[cube(anchor, window)...])\n```\n\nThe qualitative value of the signal spread is determined by computing the above measure over a range of (hyper-)cube sizes around the signal peak, and finding the point where it is maximum. Since this is only a qualitative value, we still require a hand-tuned parameter `scale` to adjust the final result.\n```{julia}\n# extract (hyper-)cubical ranges for cropping; f - measure of extent\nfunction crop_extents(data; scale=5, max_window=200, f=measure_extent)\n    anchor = Tuple(argmax(data)) # replace with robust peak finding algorithm \t\n    extent = argmax([f(data, anchor, window) for window in 1:max_window])\n\n    return cube(anchor, extent * scale)\nend\n```\n\nThe biggest assumption here is that the standard deviation curve peaks at some non-zero value of the window size. We see that this is indeed the case for a unimodal distribution using some generated 1D data.\n\n```{julia}\nlet\n    gaussian1D(x, A, x0, sig) = A * exp(-(x - x0)^2 / (2 * sig^2))\n    x = -50:0.1:50\n    y = gaussian1D.(x, 1, 20, 1)\n    yerr = 0.5 * rand(length(x))\n\n    anchor, anchorerr = argmax(y), argmax(y .+ yerr)\n    windows = 1:170\n    rng = [measure_extent(y, anchor, window) for window in windows]\n    rngerr = [measure_extent(y .+ yerr, anchor, window) for window in windows]\n\n    plot(windows, rng, lab=\"Clean signal\", lw=2, c=1)\n    plot!(windows, rngerr, lab=\"Noisy signal\", lw=2, c=2)\n    vline!([argmax(rng)], c=1, lab=\"\", ls=:dash, alpha=0.75)\n    vline!([argmax(rngerr)], c=2, lab=\"\", ls=:dash, alpha=0.75)\n\n    plot!(legend=:bottomright, xlabel=\"Independant variable\", ylabel=\"Measure of signal spread\")\nend\n```\n\nThe boxed standard deviation measure seems to always increases to reach a maximum value and continues to monotonically decrease to 0. The maximum value of this measure gives us a qualitative correspondence to the extent of the signal. We simply extract this value and use an appropriate multiplier to crop the data as required.\n\n```{julia}\nlet\n    gaussian1D(x, A, x0, sig) = A * exp(-(x - x0)^2 / (2 * sig^2))\n    x = -50:0.1:50\n    y = gaussian1D.(x, 1, 35, 1) .+ 0.5 * rand(length(x))\n    rng = crop_extents(y; max_window=10)\n    p1 = plot(x, y, lw=1, lab=\"\", title=\"Raw data\")\n    p2 = plot(x[rng...], y[rng...], lab=\"\", title=\"Cropped data\")\n    plot(p1, p2, size=(1000, 300), legend=:topleft)\nend\n```\n\n```{julia}\n#| echo: false\nlet\n    d = data[1]\n    rng = crop_extents(d)\n\n    p1 = heatmap(d, title=\"Raw image\")\n    p2 = heatmap(rng[1], rng[2], d[rng...], title=\"Cropped image\")\n    display(plot(p1, p2, size=(1000, 300)))\n\n    d = data[2]\n    rng = crop_extents(d)\n\n    p1 = heatmap(d, title=\"Raw image\")\n    p2 = heatmap(rng[1], rng[2], d[rng...], title=\"Cropped image\")\n    display(plot(p1, p2, size=(1000, 300)))\nend\n```\n\nSome caveats seem to be that:\n\n(1) The technique is highly sensitive to the anchor i.e. the peak of the signal.\n\n(2) The signal must have the following features to assure optimal performance of this technique: minimal overlap with other signals, and roughly symmetric spread (i.e., gaussian-like, without long tails).\n\n\n","srcMarkdownNoYaml":"\n\nSometimes being a (numerical) theorist gets a bit tiring. In those moments, I occasionally peak into what my colleagues are working on with the [BEC experiment](https://quantumghent.github.io/bec/) downstairs. If they happen to be facing an interesting logistical problem, its quite fun to see if it can be automated with code. One such problem popped up early on in the calibration phase of the experiment; namely, we had to profile a certain gaussian laser beam belonging to the [AOD system](https://en.wikipedia.org/wiki/Acousto-optic_deflector) to see if it was tuned correctly. Typically, this involved capturing 2D images of the intensity profile like so: \n\n```{julia}\n#| echo: false\nbegin\n    using Pkg\n    Pkg.activate(\"../../\")\n    Pkg.instantiate()\n    using JLD2, Plots, StatsBase\nend\n```\n\n```{julia}\nbegin\n    data = load(\"signal.jld2\")[\"images\"]\n    plot(heatmap(data[1], title=\"Image #1\"), heatmap(data[2], title=\"Image #2\"), size=(1000, 300))\nend\n```\n\nThese images have quite a high resolution but the actual signal is tiny and most of the space is just empty. So, before running any analysis routines on this data, it must be cropped to put the actual beam in focus. Nowadays this can be easily achieved with the host of computer vision algorithms that can be found in mature ecosystems such as OpenCV. However, I wanted to see if a simpler approach was possible here since the signal is not particularly complex in its structure. In the ideal case, it is supposed to be an exact gaussian beam, although in this particular instance, there was some odd modulation of interference fringes within the spot which is what we wanted to investigate.\n\n## Automating the cropping\nI have not spent too much time to figure out exactly why the solution works, so I simply outline the procedure here and discuss how we stumbled upon it. I should note here that what follows was largely borne out of discussions with [Dhruva Sambrani](https://dhruvasambrani.github.io/).\n\nBefore proceeding, we assume that there is only a single point of interest and it is roughly a single-peaked intensity distribution. Finding the point of interest (i.e., the signal peak) is usually not too hard since one may use boxed-averages or some other sophisticated algorithm (there is an _excellent_ [stack exchange thread](https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data) on this) to locate regions of interest where the intensity peaks. Obtaining a measure of the spread of the spot is a bit harder though. Ideally the signal is equipped with a standard deviation as it is a gaussian beam, but we cannot perform a linear regression to fit it to this model and extract the parameter as such (the whole point is to reduce the size of the image before doing these things). One may also just compute $\\sigma = \\sqrt{\\int x^2 \\cdot I(x) dx - (\\int x \\cdot I(x) dx)^2}$ using the discrete data with $x$ being the pixel co-ordinates. But this would require performing independant calculations across multiple cross-sections (either horizontal/vertical or radially outwards) and averaging those out, but we are lazy programmers trying to find the path of least action. So we instead look for some simpler qualitative measure that approximately gives us the spread.\n\nThe rough idea is as follows; we expect that the standard deviation of the intensity values around the peak of the beam should hold the information of the signal spread (there is likely a direct relation here). This is simple to compute; $stddev(I) = \\frac{1}{N} \\sum_{i} (I_i - \\bar{I})^2$ where $\\bar{I}$ is the mean intensity within the area. However, we do not know how large an area around the peak must be considered to compute this deviation. \n\nIn order to facilitate the exploration of this concept, we first write a small function to extract the indices corresponding to a (hyper-cube) of length `2 * window` centered around the point `anchor`. All the code in this post is written to be applicable regardless of the dimensionality of the data.\n```{julia}\nfunction cube(anchor, window)\n    return [\n        rmin:rmax for (rmin, rmax) in\n        zip(anchor .- window, anchor .+ window)\n    ]\nend\n```\n\nWe then define the measure of the extent of the signal as the standard deviation of the intensity values in a cube of pixels centered around the signal peak.\n```{julia}\nmeasure_extent(data, anchor, window) = std(data[cube(anchor, window)...])\n```\n\nThe qualitative value of the signal spread is determined by computing the above measure over a range of (hyper-)cube sizes around the signal peak, and finding the point where it is maximum. Since this is only a qualitative value, we still require a hand-tuned parameter `scale` to adjust the final result.\n```{julia}\n# extract (hyper-)cubical ranges for cropping; f - measure of extent\nfunction crop_extents(data; scale=5, max_window=200, f=measure_extent)\n    anchor = Tuple(argmax(data)) # replace with robust peak finding algorithm \t\n    extent = argmax([f(data, anchor, window) for window in 1:max_window])\n\n    return cube(anchor, extent * scale)\nend\n```\n\nThe biggest assumption here is that the standard deviation curve peaks at some non-zero value of the window size. We see that this is indeed the case for a unimodal distribution using some generated 1D data.\n\n```{julia}\nlet\n    gaussian1D(x, A, x0, sig) = A * exp(-(x - x0)^2 / (2 * sig^2))\n    x = -50:0.1:50\n    y = gaussian1D.(x, 1, 20, 1)\n    yerr = 0.5 * rand(length(x))\n\n    anchor, anchorerr = argmax(y), argmax(y .+ yerr)\n    windows = 1:170\n    rng = [measure_extent(y, anchor, window) for window in windows]\n    rngerr = [measure_extent(y .+ yerr, anchor, window) for window in windows]\n\n    plot(windows, rng, lab=\"Clean signal\", lw=2, c=1)\n    plot!(windows, rngerr, lab=\"Noisy signal\", lw=2, c=2)\n    vline!([argmax(rng)], c=1, lab=\"\", ls=:dash, alpha=0.75)\n    vline!([argmax(rngerr)], c=2, lab=\"\", ls=:dash, alpha=0.75)\n\n    plot!(legend=:bottomright, xlabel=\"Independant variable\", ylabel=\"Measure of signal spread\")\nend\n```\n\nThe boxed standard deviation measure seems to always increases to reach a maximum value and continues to monotonically decrease to 0. The maximum value of this measure gives us a qualitative correspondence to the extent of the signal. We simply extract this value and use an appropriate multiplier to crop the data as required.\n\n```{julia}\nlet\n    gaussian1D(x, A, x0, sig) = A * exp(-(x - x0)^2 / (2 * sig^2))\n    x = -50:0.1:50\n    y = gaussian1D.(x, 1, 35, 1) .+ 0.5 * rand(length(x))\n    rng = crop_extents(y; max_window=10)\n    p1 = plot(x, y, lw=1, lab=\"\", title=\"Raw data\")\n    p2 = plot(x[rng...], y[rng...], lab=\"\", title=\"Cropped data\")\n    plot(p1, p2, size=(1000, 300), legend=:topleft)\nend\n```\n\n```{julia}\n#| echo: false\nlet\n    d = data[1]\n    rng = crop_extents(d)\n\n    p1 = heatmap(d, title=\"Raw image\")\n    p2 = heatmap(rng[1], rng[2], d[rng...], title=\"Cropped image\")\n    display(plot(p1, p2, size=(1000, 300)))\n\n    d = data[2]\n    rng = crop_extents(d)\n\n    p1 = heatmap(d, title=\"Raw image\")\n    p2 = heatmap(rng[1], rng[2], d[rng...], title=\"Cropped image\")\n    display(plot(p1, p2, size=(1000, 300)))\nend\n```\n\nSome caveats seem to be that:\n\n(1) The technique is highly sensitive to the anchor i.e. the peak of the signal.\n\n(2) The signal must have the following features to assure optimal performance of this technique: minimal overlap with other signals, and roughly symmetric spread (i.e., gaussian-like, without long tails).\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.29","theme":["cosmo","brand","cerulean"],"title-block-banner":true,"title":"Automating image cropping","author":"Akshay Shankar, Dhruva Sambrani","date":"2025-05-04","categories":["tidbit","code","bec"],"image":"image.jpg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}