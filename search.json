[
  {
    "objectID": "posts/callbacks/index.html",
    "href": "posts/callbacks/index.html",
    "title": "The callback pattern",
    "section": "",
    "text": "One of my favourite design patterns is the Callback (also known as the Command pattern in object-oriented contexts). Loosely speaking, a callback is simply a function f whose reference has been passed on to another function g which then proceeds to invoke f upon completion at a later time. It is trivially usable in languages that implement functions as first-class citizens (where they may be passed around as arguments with no hassle). While the idea is quite simple, it can lend itself to some very powerful and intuitive user interfaces! I’ve had natural use-cases arise both during my day-to-day research as well as during game development.\nLet us consider a simple and perhaps a bit over-engineered example using Julia to demonstrate this idea. Say we want to write a generic interface for a differential equation solver. (Note that much of what I present here is simply a poor man’s version of the equivalent implementation in the behemoth that is DifferentialEquations.jl.)\n\nA generic integrator interface\nRK4 seems like a good place to start. We begin by defining a struct to hold the state of the integrator, (u, tspan), where u can be anything that implements similar and supports basic algebraic operations, and tspan is an AbstractRange specifying the time interval of problem. The remaining variables are dummies to avoid allocation in a hot loop.\n\nabstract type AbstractIntegrator end\n\nstruct RK4Integrator{T,S} &lt;: AbstractIntegrator\n    # current solver state\n    u::T\n    tspan::S\n\n    # intermediate variables\n    k1::T\n    k2::T\n    k3::T\n    k4::T\n    tmp::T\n\n    RK4Integrator(u, tspan) = new{typeof(u),typeof(tspan)}(\n        u, tspan, similar(u), similar(u), similar(u), similar(u), similar(u)\n    )\nend\n\nEvery integrator is expected to implement a step! method that expects a function f! implementing the in-place derivatve, and performs the actual time-stepping.\n\nfunction step!(integrator::RK4Integrator, f!, t)\n    (; u, tspan, k1, k2, k3, k4, tmp) = integrator\n    dt = step(tspan)\n\n    f!(k1, u, t)\n\n    @. tmp = u + dt / 2 * k1\n    f!(k2, tmp, t + dt / 2)\n\n    @. tmp = u + dt / 2 * k2\n    f!(k3, tmp, t + dt / 2)\n\n    @. tmp = u + dt * k3\n    f!(k4, tmp, t + dt)\n\n    @. u += dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n    return u\nend\n\nstep! (generic function with 1 method)\n\n\nThen, we require only one generic function that actually loops through the time-steps. Below we just implement a basic version, but there is nothing stopping us from being more sophisticated with adaptive algorithms as well.\n\nfunction solve!(f!, u0, tspan; solver, (callback!)=(iter, integrator) -&gt; nothing)\n    integrator = solver(u0, tspan)\n\n    for iter in eachindex(tspan)\n        step!(integrator, f!, tspan[iter])\n        callback!(iter, integrator)\n    end\nend\n\nsolve! (generic function with 1 method)\n\n\nAt this point, we introduce the notion of a callback as a mutating function that takes the input (iter, integrator)::(Integer, AbstractIntegrator) and is invoked at the end of every iteration. We will soon see that the callback can be utilized by the user to run custom logic within the integrator loop without ever having to touch the actual internals. In the meanwhile, we can now solve any ordinary differential equation with the RK4 method!\n\n    function dfdt!(du, u, t)\n        du[1] = -5. * u[1]\n    end\n\n    solve!(dfdt!, [5.], range(0., 1., length=100), solver = RK4Integrator)\n\nNote that this function only provides access to the value of u at the last time-step, which is a bit weird since typically we would want the evolution of the state at a time-series. While this was an artifical oversight on my part, it also provides a good opportunity to utilize callbacks to store custom data during the solver steps.\n\n\nThe callback struct\nGenerally, custom logic can be stateful (i.e, have persistent local variables) and one would need to create a closure over the function that actually performs the mutating action on the state of the integrator. However, Julia offers another alternative; namely, we can define a struct that encapsulates the data, which can then be invoked as a function with access to this data. Since both structs and functions may be invoked by means of a function call syntax, I will generically refer to them as callables henceforth.\nIn order to define a generic interface, we first need to think about what the general usecase of callbacks would be. Typically we expect that callbacks will have the specific form of evaluating whether a certain condition is met at the time of invocation, and if so, it performs a certain effect that mutates the state of the integrator. For example, we may want to save a certain variable every 10 iterations, or normalize the state whenever it deviates beyond a certain threshold, etc. So, we define a Callback struct as a collection of two callables; (1) condition with signature (iter, integrator) -&gt; bool and (2) effect with signature (iter, integrator) -&gt; integrator, although it is intended to be mutating.\n\nbegin\n    struct Callback{C,E}\n        \"condition for performing callback: (iter, integrator) -&gt; bool\"\n        condition::C\n        \"callback function acting on solver state: (iter, integrator) -&gt; integrator\"\n        effect::E\n    end\n    \n    condition(p::Callback) = p.condition\n    effect(p::Callback) = p.effect\n    \n    function (p::Callback)(iter, integrator)\n        if condition(p)(iter, integrator)\n            effect(p)(iter, integrator)\n        end\n    \n        return integrator\n    end\nend\n\nWe can further define a CallbackList that sequentially invokes its elements if we have more than one callback.\n\nbegin\n    struct CallbackList\n        callbacks::Vector{Callback}\n    end\n\n    function (p::CallbackList)(iter, integrator)\n        for callback in p.callbacks\n            callback(iter, integrator)\n        end\n\n        return integrator\n    end\n\n    Base.getindex(p::CallbackList, idx) = getindex(p.callbacks, idx)\n    Base.length(p::CallbackList) = length(p.callbacks)\nend\n\nNow that the basic structure is in place, let us implement some common conditions. Again, these don’t have to be structs, but since the specific use-cases here require statefulness, they are an appropriate choice. Note that we have not placed explicit safegaurds to statically check whether the function call has the right signature, so the program would fail at run-time if the signature does not match what is expected.\n\nbegin\n    # trigger every n iterations\n    mutable struct OnIterElapsed\n        \"number of iterations between trigger\"\n        save_freq::Int\n\n        loop::Bool # if true, continuously fires, otherwise it is a one-shot condition\n        flag::Bool # true if condition has been fired once\n\n        OnIterElapsed(save_freq, loop=true) = new(save_freq, loop, false)\n    end\n\n    function (p::OnIterElapsed)(iter, integrator)\n        res = iszero(iter % p.save_freq)\n        return p.loop ? res : (!p.flag ? (p.flag = res; p.flag) : false)\n    end\n\n    # maybe for saving data to file as a backup during long program runs\n    mutable struct OnRealTimeElapsed\n        \"starting time in seconds\"\n        start_tick::Float64\n        \"number of seconds between trigger\"\n        save_freq::Float64\n\n        # :s - second, :m - minute, :h - hour\n        function OnRealTimeElapsed(freq, unit=:m)\n            if unit == :m\n                freq *= 60\n            elseif unit == :h\n                freq *= 3600\n            elseif unit != :s\n                throw(ArgumentError(\"invalid unit `:$unit`, expected `:s`, `:m` or `:h`\"))\n            end\n\n            new(time(), freq)\n        end\n    end\n\n    # only gets called AFTER an iteration is complete!\n    (p::OnRealTimeElapsed)(iter, state, H, envs) = ((time() - p.start_tick) &gt; p.save_freq) ? (p.start_tick = time(); true) : false\nend\n\nWe now define a generic effect that simply computes some specified observables using the integrator state. We do so by defining a struct RecordObservable which expects an input recipe which is a named tuple of pairs like (name, function to compute observable). For example; (modsq = (iter, integrator) -&gt; integrator.u^2, iter = (iter, integrator) -&gt; iter). It then stores the result in data whenever the condition of its parent Callback returns true. While this is a trivial example, it may be quite useful if there is some internal integrator state (which is not simply the solution u) that must be tracked.\n\nbegin\n    struct RecordObservable{D,O}\n        \"collection of string-array pairs containing observable data\"\n        data::D\n        \"functions to compute observable data\"\n        observables::O\n\n        function RecordObservable(recipe)\n            names = keys(recipe)\n            observables = values(recipe)\n            data = NamedTuple{names}(([] for _ in eachindex(names)))\n            return new{typeof(data),typeof(observables)}(data, observables)\n        end\n    end\n\n    function Base.getproperty(p::RecordObservable, key::Symbol)\n        if key in fieldnames(typeof(p))\n            return getfield(p, key)\n        else\n            return getproperty(p.data, key)\n        end\n    end\n\n    # Base.iterate(p::RecordObservable, i...) = iterate(p.data, i...)\n    Base.length(p::RecordObservable) = length(p.data)\n\n    function (p::RecordObservable)(iter, integrator)\n        for i in 1:length(p)\n            push!(p.data[i], p.observables[i](iter, integrator))\n        end\n\n        return integrator\n    end\nend\n\nWe can now finally record the solution as a time-series at every iteration and visualize it. (Note that it is strictly necessary to wrap the keyword argument callback! in paranthesis because there is an ambiguity in syntax due to a possible != otherwise.)\n\nlet\n    record_state = Callback(\n        OnIterElapsed(1),\n        RecordObservable((u=(iter, integrator) -&gt; copy(integrator.u),))\n    )\n    solve!(dfdt!, [5.0], range(0.0, 1.0, length=100), solver=RK4Integrator, (callback!)=record_state)\n    plot(first.(record_state.effect.u))\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerfect! Perhaps a more realistic use-case is to specify dynamical conditions that kick in at some intermediate time, for example, a random kick every n iterations. This can be done like so:\n\nlet\n    record_state = Callback(\n        OnIterElapsed(1),\n        RecordObservable((u=(iter, integrator) -&gt; copy(integrator.u),))\n    )\n\n    kick_callback = Callback(\n        OnIterElapsed(20),\n        (iter, integrator) -&gt; integrator.u[1] += (2 * rand() - 1),\n    )\n    solve!(dfdt!, [5.0], range(0.0, 1.0, length=100), solver=RK4Integrator, (callback!)=CallbackList([record_state, kick_callback]))\n    plot(first.(record_state.effect.u))\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI think is quite a nice example demonstrating how the callback pattern allows modularity and extensibility for the user with no need to poke into the internals of the core solver loop. However, it should be noted that design patterns such as this one tend to quickly ramp up in complexity and the overhead introduced both in compilation time and developer maintanence time can often outweigh its usefulness. So its important to keep your specific use-case in mind and try to use them sparingly only when strictly required."
  },
  {
    "objectID": "posts/what-is-a-bec/index.html",
    "href": "posts/what-is-a-bec/index.html",
    "title": "What is a BEC",
    "section": "",
    "text": "Work in progress!\n\\[\n\\langle \\hat{\\Psi}(r) \\rangle \\neq 0\n\\]\n\\[\n\\lim_{|r-r'|\\to\\infty}\\langle \\hat{\\Psi}^{\\dagger}(r)\\hat{\\Psi}(r')\\rangle = \\langle \\hat{\\Psi}^{\\dagger}(r)\\rangle \\langle \\hat{\\Psi}(r')\\rangle \\neq 0\n\\]\n\\[\n\\langle \\hat{\\Psi}^{\\dagger}(r)\\hat{\\Psi}(r')\\rangle = \\sum_{i} n_i \\cdot \\chi_i(r)^* \\chi_i(r')\n\\]\nwhere \\(n_0=\\) max \\((n_i) \\sim \\mathcal{O}(N)\\)."
  },
  {
    "objectID": "posts/signal-crop/index.html",
    "href": "posts/signal-crop/index.html",
    "title": "Automating image cropping",
    "section": "",
    "text": "Sometimes being a (numerical) theorist gets a bit tiring. In those moments, I occasionally peak into what my colleagues are working on with the BEC experiment downstairs. If they happen to be facing an interesting logistical problem, its quite fun to see if it can be automated with code. One such problem popped up early on in the calibration phase of the experiment; namely, we had to profile a certain gaussian laser beam belonging to the AOD system to see if it was tuned correctly. Typically, this involved capturing 2D images of the intensity profile like so:\nActivating project at `~/Documents/PhDstuff/ResearchTidbits`\nbegin\n    data = load(\"signal.jld2\")[\"images\"]\n    plot(heatmap(data[1], title=\"Image #1\"), heatmap(data[2], title=\"Image #2\"), size=(1000, 300))\nend\nThese images have quite a high resolution but the actual signal is tiny and most of the space is just empty. So, before running any analysis routines on this data, it must be cropped to put the actual beam in focus. Nowadays this can be easily achieved with the host of computer vision algorithms that can be found in mature ecosystems such as OpenCV. However, I wanted to see if a simpler approach was possible here since the signal is not particularly complex in its structure. In the ideal case, it is supposed to be an exact gaussian beam, although in this particular instance, there was some odd modulation of interference fringes within the spot which is what we wanted to investigate."
  },
  {
    "objectID": "posts/signal-crop/index.html#automating-the-cropping",
    "href": "posts/signal-crop/index.html#automating-the-cropping",
    "title": "Automating image cropping",
    "section": "Automating the cropping",
    "text": "Automating the cropping\nI have not spent too much time to figure out exactly why the solution works, so I simply outline the procedure here and discuss how we stumbled upon it. I should note here that what follows was largely borne out of discussions with Dhruva Sambrani.\nBefore proceeding, we assume that there is only a single point of interest and it is roughly a single-peaked intensity distribution. Finding the point of interest (i.e., the signal peak) is usually not too hard since one may use boxed-averages or some other sophisticated algorithm (there is an excellent stack exchange thread on this) to locate regions of interest where the intensity peaks. Obtaining a measure of the spread of the spot is a bit harder though. Ideally the signal is equipped with a standard deviation as it is a gaussian beam, but we cannot perform a linear regression to fit it to this model and extract the parameter as such (the whole point is to reduce the size of the image before doing these things). One may also just compute \\(\\sigma = \\sqrt{\\int x^2 \\cdot I(x) dx - (\\int x \\cdot I(x) dx)^2}\\) using the discrete data, \\(I(x_i)\\) with \\(x_i\\) being the pixel co-ordinates. But in higher dimensions, this would require performing independant calculations across multiple cross-sections (either horizontal/vertical or radially outwards) and averaging those out, but we are lazy programmers trying to find the path of least action. So we instead look for some simpler qualitative measure that approximately gives us the spread.\nThe rough idea is as follows; we expect that the standard deviation of the intensity values around the peak of the beam should hold the information of the signal spread (there is likely a direct relation here). This is simple to compute; \\(stddev(I) = \\frac{1}{N} \\sum_{i} (I_i - \\bar{I})^2\\) where \\(\\bar{I}\\) is the mean intensity within the area. However, we do not know how large an area around the peak must be considered to compute this deviation.\nIn order to facilitate the exploration of this concept, we first write a small function to extract the indices corresponding to a (hyper-cube) of length 2 * window centered around the point anchor. All the code in this post is written to be applicable regardless of the dimensionality of the data.\n\nfunction cube(anchor, window)\n    return [\n        rmin:rmax for (rmin, rmax) in\n        zip(anchor .- window, anchor .+ window)\n    ]\nend\n\ncube (generic function with 1 method)\n\n\nWe then define the measure of the extent of the signal as the standard deviation of the intensity values in a cube of pixels centered around the signal peak.\n\nmeasure_extent(data, anchor, window) = std(data[cube(anchor, window)...])\n\nmeasure_extent (generic function with 1 method)\n\n\nThe qualitative value of the signal spread is determined by computing the above measure over a range of (hyper-)cube sizes around the signal peak, and finding the point where it is maximum. Since this is only a qualitative value, we still require a hand-tuned parameter scale to adjust the final result.\n\n# extract (hyper-)cubical ranges for cropping; f - measure of extent\nfunction crop_extents(data; scale=5, max_window=200, f=measure_extent)\n    anchor = Tuple(argmax(data)) # replace with robust peak finding algorithm   \n    extent = argmax([f(data, anchor, window) for window in 1:max_window])\n\n    return cube(anchor, extent * scale)\nend\n\ncrop_extents (generic function with 1 method)\n\n\nThe biggest assumption here is that the standard deviation curve peaks at some non-zero value of the window size. We see that this is indeed the case for a unimodal distribution using some generated 1D data.\n\nlet\n    gaussian1D(x, A, x0, sig) = A * exp(-(x - x0)^2 / (2 * sig^2))\n    x = -50:0.1:50\n    y = gaussian1D.(x, 1, 20, 1)\n    yerr = 0.5 * rand(length(x))\n\n    anchor, anchorerr = argmax(y), argmax(y .+ yerr)\n    windows = 1:170\n    rng = [measure_extent(y, anchor, window) for window in windows]\n    rngerr = [measure_extent(y .+ yerr, anchor, window) for window in windows]\n\n    plot(windows, rng, lab=\"Clean signal\", lw=2, c=1)\n    plot!(windows, rngerr, lab=\"Noisy signal\", lw=2, c=2)\n    vline!([argmax(rng)], c=1, lab=\"\", ls=:dash, alpha=0.75)\n    vline!([argmax(rngerr)], c=2, lab=\"\", ls=:dash, alpha=0.75)\n\n    plot!(legend=:bottomright, xlabel=\"Independant variable\", ylabel=\"Measure of signal spread\")\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe boxed standard deviation measure seems to monotonically increase upto a maximum value and then continues to monotonically decrease. The window size which achieves the maximum value of this measure gives us a qualitative correspondence to the extent of the signal. We simply extract this value and use an appropriate multiplier to crop the data as required.\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome caveats with this method seems to be that:\n\nhigh sensitivity to estimated location of the peak of the signal, i.e, the anchor.\nthe signal must have minimal overlap with other signals, and roughly symmetric spread (i.e., gaussian-like, without long tails) to ensure optimal performance.\n\nFor what came out of a quick text conversation with a friend, this was a pretty interesting find!"
  },
  {
    "objectID": "ideas.html",
    "href": "ideas.html",
    "title": "ResearchTidbits",
    "section": "",
    "text": "single particle hamiltonian from energy spectrum\nsuperfluid stiffness/ rotation as an artificial gauge field"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "Hi! I’m Akshay, a PhD student at QuantumGroup@UGent with an interest in the exotic physics of Bose-Einstein condensates and programming. I am currently working on utilizing Tensor Network techniques to study BEC systems in the context of quantum simulation experiments. When I’m not performing research, I enjoy making games with the Godot engine. You can find out more about the things I work on in my main website.\nOver the past year, I’ve found that my research seems to involve solving many tiny problems which have some insight to offer but not enough to share in any usual platforms of scientific discourse. As an attempt to preserve these tidbits from fading into obscurity as I inevitably forget about them, I have begun documenting them here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ResearchTidbits",
    "section": "",
    "text": "What is a BEC\n\n\n\ntidbit\n\nbec\n\n\n\n\n\n\n\n\n\nMay 5, 2025\n\n\nAkshay Shankar\n\n\n\n\n\n\n\n\n\n\n\n\nSuperfluidity as a response to phase twists\n\n\n\ntidbit\n\nbec\n\n\n\n\n\n\n\n\n\nMay 5, 2025\n\n\nAkshay Shankar\n\n\n\n\n\n\n\n\n\n\n\n\nThe callback pattern\n\n\n\ntidbit\n\ncode\n\n\n\n\n\n\n\n\n\nMay 5, 2025\n\n\nAkshay Shankar\n\n\n\n\n\n\n\n\n\n\n\n\nLinearly indexing a 2D grid\n\n\n\ntidbit\n\nnumber theory\n\n\n\n\n\n\n\n\n\nSep 15, 2024\n\n\nAkshay Shankar\n\n\n\n\n\n\n\n\n\n\n\n\nAutomating image cropping\n\n\n\ntidbit\n\ncode\n\nbec\n\n\n\n\n\n\n\n\n\nNov 21, 2023\n\n\nAkshay Shankar, Dhruva Sambrani\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/indexing-scheme/index.html",
    "href": "posts/indexing-scheme/index.html",
    "title": "Linearly indexing a 2D grid",
    "section": "",
    "text": "Recently, I had to write an exact diagonalization routine to solve for the ground state of a system of interacting bosons in the continuum. Generally this simply involves choosing a single-particle basis set, \\(\\{\\phi_i(\\vec{r})\\}|_{i=1}^N\\) such that a many-particle basis set may be constructed by enumerating the Fock states, \\(\\{\\ket{n_1, n_2, \\dots, n_N}\\}\\) respecting the bosonic/fermionic symmetry. These states can then be utilized to explicitly construct the Hamiltonian by computing its matrix elements.\nWe see then that the core subroutine is agnostic to the physical dimensionality of the problem as this information is already abstracted out at the level of the Fock states. In such a case, extending a code developed with 1D systems in mind to higher dimensions is as simple as finding a consistent linear indexing scheme for the single-particle basis set in order to construct the basis of Fock states.\nIn my particular case, I was working with a 1D system under the influence of a harmonic potential, so the Hermite modes, \\(\\{h_n(x)\\}\\) where \\(n \\in \\mathbb{N}\\) with single-particle energies \\(\\epsilon(n) = \\hbar \\omega (n + 1/2)\\), served as a natural single-particle basis. Upon requiring an extension to 2D, a natural choice for the basis can be constructed as a product of the 1D modes, \\(\\{h_{n_x}(x)h_{n_y}(y)\\}\\) where \\(n_x, n_y \\in \\mathbb{N}\\) with single-particle energies \\(\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)\\). We thus require a mapping scheme \\(\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}\\) in order to linearly index this basis set."
  },
  {
    "objectID": "posts/indexing-scheme/index.html#constructing-the-indexing-scheme",
    "href": "posts/indexing-scheme/index.html#constructing-the-indexing-scheme",
    "title": "Linearly indexing a 2D grid",
    "section": "Constructing the indexing scheme",
    "text": "Constructing the indexing scheme\nThe modes are labelled by two numbers \\((n_x, n_y)\\), both of which are non-negative integers. A natural ordering scheme presents itself in the form of increasing energy eigenvalues, however the spectrum is fairly degenerate since \\(\\epsilon(n_x, n_y) = \\hbar \\omega (n_x + n_y + 1)\\). This degeneracy actually lets us come up with a scheme quite easily.\n\n\n\n\n\nWe can break down the scheme into two pieces; (1) identify the degeneracy level, (2) identify the location within the level. We know that a mode \\((n_x, n_y)\\) must belong to a level with degeneracy \\(n_x + n_y + 1\\). This means that the number of elements in the lower energy levels is given by:\n\\[\\begin{equation} \\sum_{n = 1}^{n_x + n_y} n  = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2} \\end{equation}\\]\nWithin the level, \\(n_y\\) itself provides a natural way of ordering the modes. We can thus write a linear indexing scheme like so:\n\\[\\begin{equation} n = \\frac{(n_x + n_y)(n_x + n_y + 1)}{2}  + n_y \\end{equation}\\]\nOf course, we could equivalently use \\(n_x\\) instead.\nAlthough it is not readily apparent due to the quadratic nature of this mapping, we expect that it is invertible by construction. In such a case, we have effectively constructed a bijection from the natural numbers to a pair of natural numbers. In fact, what we have here is Cantor’s pairing function, which is the only bijective quadratic function on \\(\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}\\). The existence of this function shows that 2-tuples of natural numbers are countable! By extension, we can easily show that the set of rational numbers are countable as well.\nWhile its not too surprising that this result is well-known and has ties to number theory, I found it really nice that it naturally popped up as a practical solution to a seemingly unrelated logistical problem involving the numerical implementation of exact diagonalization."
  },
  {
    "objectID": "posts/phase-twists/index.html",
    "href": "posts/phase-twists/index.html",
    "title": "Superfluidity as a response to phase twists",
    "section": "",
    "text": "Work in progress!"
  }
]